<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
<head>
<title>Para</title>
<meta charset='UTF-8' />
<meta content='IE=edge,chrome=1' http-equiv='X-UA-Compatible' />
<meta content='width=device-width, initial-scale=1.0' name='viewport' />
<link href='./style.css?1311870909' rel='stylesheet' />
<script src='http://cachedcommons.org/cache/prettify/1.0.0/javascripts/prettify-min.js' type='text/javascript'></script>
<script src='http://cdnjs.cloudflare.com/ajax/libs/jquery/1.6.2/jquery.min.js' type='text/javascript'></script>
<script src='./proscribe.js?1311870909' type='text/javascript'></script>
</head>
<body>
<div id='top'>
<a href='' id='logo'>
Para
</a>
</div>
<div id='area'>
<div id='content'>
<div class='c'>
<div id='crumbs'>
<strong>Para</strong>
</div>
<hgroup>
<h1>Para</h1>
</hgroup>
<div class='content'>
<p>Super-simple parallel testing</p>

<h4>Parallel testing</h4>

<p>Para is a simple test framework with one killer feature: your tests will be
ran in parallel. This example below will have all tests take place
simultaneously.</p>

<pre><code>$ gem install para
</code></pre>

<h4>Creating tests</h4>

<p>Create tests by subclassing <code>Para::Test</code>.</p>

<pre><code>[mytest.rb (rb)]
require 'para'

class MyTest &lt; Para::Test
  enable_parallel

  setup do
    @nothing = nil
  end

  test "assertions" do
    3.should == 3
    100.should &gt;= 3
    @nothing.should.be.nil
    sleep 1          # &lt;-- stop for 1 second!
  end

  test "arrays" do
    %w[2 3 4].should.be.kind_of(Array)
    sleep 1          # &lt;-- stop for 1 second!
  end

  test "failure" do
    3.should == 4    # &lt;-- this will fail
  end

  test "error" do
    100 / 0          # &lt;-- this will produce an error
  end
end
</code></pre>

<h4>Run</h4>

<p>Notice how this takes <strong>1</strong> second to run. It should otherwise take <strong>2</strong>
seconds in another testing framework (notice the two <code>sleep</code>s in the code).</p>

<pre><code>$ ruby mytest.rb

..FE

Failed: 3 is not equal to 4.
  mytest.rb:6:in `test_failure'

Error: ZeroDivisionError: divided by 0
  mytest.rb:24:in `/'
  mytest.rb:24:in `test_failure'

Finished in 1.00204 seconds.
5 assertions, 4 passed, 1 failures, 1 errors
</code></pre>

<h2>Threads</h2>

<h4>Thread management</h4>

<p>Use <code>enable_parallel</code> to make your tests run in different threads.
different thread. To find out which thread you're on, use <code>#thread</code>.</p>

<pre><code>class MyTest &lt; Para::Test
  enable_parallel

  setup do
    # `thread` will return an integer between 0 and 2.
    port = 6379 + thread
    @redis = Redis.connect("redis://127.0.0.1:#{port}")
  end
end
</code></pre>

<h4>Adding more threads</h4>

<p>To run with a maximum of 3 threads, set the <code>THREAD</code> environment
variable.</p>

<pre><code>$ THREADS=3 ruby mytest.rb
</code></pre>

<h2>Setup/teardown</h2>

<h4>Setup and teardown</h4>

<p>Define a <code>setup</code> and/or <code>teardown</code> block to define what will be ran before and
after each test.</p>

<pre><code>class MyTest &lt; Para::Test
  setup do
    @book = Book.find_or_create(:name =&gt; "Darkly Dreaming Dexter")
  end

  teardown do
    @book.destroy
  end

  test "name" do
    @book.name.should == "Darkly Dreaming Dexter"
  end
end
</code></pre>

<h2>Should</h2>

<h4>RSpec-style assertions</h4>

<p>More RSpec-like assertions are supported.</p>

<pre><code>test "asserting equality" do
  3.should == 3
end

.should.equal (or should ==)
.should.be (or should ===)
.should.be.nil
.should.be.close(number, delta)
.should.match(regex), (or .should =~)
.should.be.an.instance_of(klass)
.should.be.a.kind_of(klass)
.should.respond_to(method)
.should.raise(exception)
.should.throw(symbol)
.should.satisfy { ... }
</code></pre>

<h4>be, a, an</h4>

<p>You can add <code>.be</code>, <code>.a</code>, and <code>.an</code> -- they do nothing. These two work the same
way.</p>

<pre><code>3.should.be == 3
3.should == 3
</code></pre>

<h4>Negating tests</h4>

<p>You can negate a test by adding <code>.not</code>. (eg: <code>.should.not.be.nil</code>)</p>

<pre><code>3.should.not == 3
object.should.respond_to(:call)
</code></pre>

<h2>Test::Unit</h2>

<h4>Test::Unit backward compatibility</h4>

<p>Migrate your current tests to Para by changing <code>require 'test/unit'</code> to
<code>require 'para/test/unit'</code>. This will give you <code>Test::Unit::TestCase</code>.</p>

<pre><code>require 'para/test/unit'

class Test::Unit::TestCase
  def test_something
    assert "It works!".size &gt; 0
  end
end
</code></pre>

<h4>Test::Unit-style assertions</h4>

<p>Minitest/Test::Unit assertions are also supported.</p>

<pre><code>test "assertions" do
  assert true
  assert_equal 3, 3
  assert_equal @something, 3, "The variable @something was set wrong."
end

assert STATEMENT
assert_equal X, Y
assert_not_equal X, Y
assert_same X, Y
assert_not_same X, Y
assert_nil X
assert_not_nil X
assert_include HAYSTACK, NEEDLE
assert_in_delta X, Y[, DELTA]
assert_match REGEX, STRING
assert_no_match REGEX, STRING
assert_instance_of TYPE, OBJECT
assert_kind_of TYPE, OBJECT
assert_respond_to OBJECT, METHOD
assert_raises EXCEPTION { ... }
assert_nothing_raised { ... }
assert_throws SYMBOL { ... }
assert_nothing_thrown { ... }
assert_block { ... }
</code></pre>

<h4>Refute</h4>

<p>If you replace <code>assert</code> with <code>refute</code> (eg, <code>refute_nil</code>), it will work in
reverse.</p>

<pre><code># These two are the name
refute_equal 2, 3
assert_not_equal 2, 3
</code></pre>

<h4>Test::Unit-style tests</h4>

<p>You can also define tests by making a method that starts with <code>test_</code>.
The <code>setup</code> and <code>teardown</code> methods are also supported.</p>

<pre><code>class MyTest &lt; Para::Test
  def setup
    @three = 3
  end

  def test_equality
    @three.should == 3
    assert_equal @three, 3
  end
end
</code></pre>

<h2>Nested tests</h2>

<h4>Nested tests</h4>

<p>You can nest tests using <code>describe</code> or <code>context</code> (both are synonyms).</p>

<pre><code>class MyTest &lt; ParaTest
  setup do
    @number = 100
  end

  test "number" do
    @number.should == 100
  end

  context "Subcontext" do
    setup do
      # This will be ran after the first `setup` block above.
      @number += 10
    end

    test "number, again" do
      @number.should == 110
    end
  end
end
</code></pre>

<h2>Acknowledgements</h2>

<p><em>Note: this is a proof-of-concept project and was never envisioned to be used
in production.</em></p>

<ul>
<li>Assertion API modeled after Test::Unit</li>
<li>RSpec-like assertions taken from <a href="http://github.com/rstacruz/renvy">REnvy</a></li>
<li>Nested tests taken from <a href="http://github.com/citrusbyte/contest">Contest</a></li>
</ul>


<p>MIT license.</p>

<p><a href="http://github.com/rstacruz/para" title="Source code">GitHub</a></p>

<section class='footer'>
<div class='left'>
<strong>
Para
</strong>
</div>
</section>
</div>
</div>
<nav id='nav'>
</nav>
</div>
</div>
</body>
</html>
